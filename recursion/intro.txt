Recursion
Do something over and over again until you hit a stopping point
Process that calls itself 

Call Stack:
To keep track of when functions should be called
Pushed to top of stack when a function is invoked
Popped off top when javascript sees return keyword or when function ends

Make sure you have a stopping point conditional in place aka a “base case”
Make sure different data gets sent as an argument into function

You pile up the stack 
You return a call to itself 
6
5
4
3
2
1

At 6 for whatever reason you stopped because you ran into a base case
A base case prevents the stack from overflowing 

Once that’s hit, it goes down the stack, it will call 6 first 
6
5
4
3
2
1

Whatever is returned from 6 gets sent into 5
5(6)
4
3
2
1

4(5(6))
3
2
1

3(4(5(6)))
2
1

2(3(4(5(6))))
1

1(2(3(4(5(6)))))
Finished 

Some strategies seen: 

Return num1 * factorial(nextNum)
This will branch off of num as the root and heads towards the right of it
Num1 -> * Num2 -> * Num3 -> * Num4

Return reverse(word.slice(1)) + word[0]
This will branch off of word[0] as the root and head towards the left of it
reverse(“word”)
“w”

“o”
“w”

“r”
“o”
“w”

“d"
“r”
“o”
“w”

“d” + <- “r” + <- “o + <- “w”
“drow”

79092342 — count how many 9s there are:
//helper func
function isNum(num, arr){
    return (arr[0] === num ? 1 : 0);
}

function numOf9s(arr){
    if(arr.length === 1){
        return isNum(9, arr);
    }
    return numOf9s(arr.slice(1)) + isNum(9, arr);
}

let num9s = numOf9s([2,2,9,3,1,5,9,9]);